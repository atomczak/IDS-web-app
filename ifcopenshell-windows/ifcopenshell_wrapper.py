# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ifcopenshell_wrapper')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ifcopenshell_wrapper')
    _ifcopenshell_wrapper = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ifcopenshell_wrapper', [dirname(__file__)])
        except ImportError:
            import _ifcopenshell_wrapper
            return _ifcopenshell_wrapper
        try:
            _mod = imp.load_module('_ifcopenshell_wrapper', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ifcopenshell_wrapper = swig_import_helper()
    del swig_import_helper
else:
    import _ifcopenshell_wrapper
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ifcopenshell_wrapper.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _ifcopenshell_wrapper.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ifcopenshell_wrapper.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ifcopenshell_wrapper.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ifcopenshell_wrapper.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ifcopenshell_wrapper.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ifcopenshell_wrapper.SwigPyIterator_copy(self)

    def next(self):
        return _ifcopenshell_wrapper.SwigPyIterator_next(self)

    def __next__(self):
        return _ifcopenshell_wrapper.SwigPyIterator___next__(self)

    def previous(self):
        return _ifcopenshell_wrapper.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ifcopenshell_wrapper.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ifcopenshell_wrapper.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ifcopenshell_wrapper.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ifcopenshell_wrapper.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ifcopenshell_wrapper.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ifcopenshell_wrapper.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ifcopenshell_wrapper.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ifcopenshell_wrapper.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class settings(_object):
    """Proxy of C++ IfcGeom::IteratorSettings class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, settings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, settings, name)
    __repr__ = _swig_repr
    WELD_VERTICES = _ifcopenshell_wrapper.settings_WELD_VERTICES
    USE_WORLD_COORDS = _ifcopenshell_wrapper.settings_USE_WORLD_COORDS
    CONVERT_BACK_UNITS = _ifcopenshell_wrapper.settings_CONVERT_BACK_UNITS
    USE_BREP_DATA = _ifcopenshell_wrapper.settings_USE_BREP_DATA
    SEW_SHELLS = _ifcopenshell_wrapper.settings_SEW_SHELLS
    FASTER_BOOLEANS = _ifcopenshell_wrapper.settings_FASTER_BOOLEANS
    DISABLE_OPENING_SUBTRACTIONS = _ifcopenshell_wrapper.settings_DISABLE_OPENING_SUBTRACTIONS
    DISABLE_TRIANGULATION = _ifcopenshell_wrapper.settings_DISABLE_TRIANGULATION
    APPLY_DEFAULT_MATERIALS = _ifcopenshell_wrapper.settings_APPLY_DEFAULT_MATERIALS
    INCLUDE_CURVES = _ifcopenshell_wrapper.settings_INCLUDE_CURVES
    EXCLUDE_SOLIDS_AND_SURFACES = _ifcopenshell_wrapper.settings_EXCLUDE_SOLIDS_AND_SURFACES
    NO_NORMALS = _ifcopenshell_wrapper.settings_NO_NORMALS
    GENERATE_UVS = _ifcopenshell_wrapper.settings_GENERATE_UVS
    APPLY_LAYERSETS = _ifcopenshell_wrapper.settings_APPLY_LAYERSETS
    SEARCH_FLOOR = _ifcopenshell_wrapper.settings_SEARCH_FLOOR
    SITE_LOCAL_PLACEMENT = _ifcopenshell_wrapper.settings_SITE_LOCAL_PLACEMENT
    BUILDING_LOCAL_PLACEMENT = _ifcopenshell_wrapper.settings_BUILDING_LOCAL_PLACEMENT
    VALIDATE_QUANTITIES = _ifcopenshell_wrapper.settings_VALIDATE_QUANTITIES
    LAYERSET_FIRST = _ifcopenshell_wrapper.settings_LAYERSET_FIRST
    EDGE_ARROWS = _ifcopenshell_wrapper.settings_EDGE_ARROWS
    DISABLE_BOOLEAN_RESULT = _ifcopenshell_wrapper.settings_DISABLE_BOOLEAN_RESULT
    NO_WIRE_INTERSECTION_CHECK = _ifcopenshell_wrapper.settings_NO_WIRE_INTERSECTION_CHECK
    NO_WIRE_INTERSECTION_TOLERANCE = _ifcopenshell_wrapper.settings_NO_WIRE_INTERSECTION_TOLERANCE
    STRICT_TOLERANCE = _ifcopenshell_wrapper.settings_STRICT_TOLERANCE
    NUM_SETTINGS = _ifcopenshell_wrapper.settings_NUM_SETTINGS

    def __init__(self):
        """__init__(IfcGeom::IteratorSettings self) -> settings"""
        this = _ifcopenshell_wrapper.new_settings()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def deflection_tolerance(self):
        """deflection_tolerance(settings self) -> double"""
        return _ifcopenshell_wrapper.settings_deflection_tolerance(self)


    def angular_tolerance(self):
        """angular_tolerance(settings self) -> double"""
        return _ifcopenshell_wrapper.settings_angular_tolerance(self)


    def set_deflection_tolerance(self, value):
        """set_deflection_tolerance(settings self, double value)"""
        return _ifcopenshell_wrapper.settings_set_deflection_tolerance(self, value)


    def set_angular_tolerance(self, value):
        """set_angular_tolerance(settings self, double value)"""
        return _ifcopenshell_wrapper.settings_set_angular_tolerance(self, value)


    def force_space_transparency(self, *args):
        """
        force_space_transparency(settings self) -> double
        force_space_transparency(settings self, double value)
        """
        return _ifcopenshell_wrapper.settings_force_space_transparency(self, *args)


    def get(self, setting):
        """get(settings self, IfcGeom::IteratorSettings::SettingField setting) -> bool"""
        return _ifcopenshell_wrapper.settings_get(self, setting)


    def set(self, setting, value):
        """set(settings self, IfcGeom::IteratorSettings::SettingField setting, bool value)"""
        return _ifcopenshell_wrapper.settings_set(self, setting, value)

    __swig_setmethods__["offset"] = _ifcopenshell_wrapper.settings_offset_set
    __swig_getmethods__["offset"] = _ifcopenshell_wrapper.settings_offset_get
    if _newclass:
        offset = _swig_property(_ifcopenshell_wrapper.settings_offset_get, _ifcopenshell_wrapper.settings_offset_set)
    __swig_setmethods__["rotation"] = _ifcopenshell_wrapper.settings_rotation_set
    __swig_getmethods__["rotation"] = _ifcopenshell_wrapper.settings_rotation_get
    if _newclass:
        rotation = _swig_property(_ifcopenshell_wrapper.settings_rotation_get, _ifcopenshell_wrapper.settings_rotation_set)


    old_init = __init__

    def __init__(self, **kwargs):
       	self.old_init()
       	for k, v in kwargs.items():
       		self.set(getattr(self, k), v)

    def __repr__(self):
    	def d():
    		import numbers
    		for x in dir(self):
    			if x.isupper() and x not in {"NUM_SETTINGS", "USE_PYTHON_OPENCASCADE"}:
    				v = getattr(self, x)
    				if isinstance(v, numbers.Integral):
    					yield x

    	return "%s(%s)" % (
    		type(self).__name__,
    		(", ".join(map(lambda x: "%s = %r" % (x, self.get(getattr(self, x))), d())))
    	)


    __swig_destroy__ = _ifcopenshell_wrapper.delete_settings
    __del__ = lambda self: None
settings_swigregister = _ifcopenshell_wrapper.settings_swigregister
settings_swigregister(settings)

class ElementSettings(settings):
    """Proxy of C++ IfcGeom::ElementSettings class."""

    __swig_setmethods__ = {}
    for _s in [settings]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElementSettings, name, value)
    __swig_getmethods__ = {}
    for _s in [settings]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElementSettings, name)
    __repr__ = _swig_repr

    def __init__(self, settings, unit_magnitude, element_type):
        """__init__(IfcGeom::ElementSettings self, settings settings, double unit_magnitude, std::string const & element_type) -> ElementSettings"""
        this = _ifcopenshell_wrapper.new_ElementSettings(settings, unit_magnitude, element_type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def unit_magnitude(self):
        """unit_magnitude(ElementSettings self) -> double"""
        return _ifcopenshell_wrapper.ElementSettings_unit_magnitude(self)


    def element_type(self):
        """element_type(ElementSettings self) -> std::string const &"""
        return _ifcopenshell_wrapper.ElementSettings_element_type(self)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_ElementSettings
    __del__ = lambda self: None
ElementSettings_swigregister = _ifcopenshell_wrapper.ElementSettings_swigregister
ElementSettings_swigregister(ElementSettings)

class Material(_object):
    """Proxy of C++ IfcGeom::Material class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Material, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Material, name)
    __repr__ = _swig_repr

    def __init__(self, style=None):
        """
        __init__(IfcGeom::Material self, IfcGeom::SurfaceStyle const * style=None) -> Material
        __init__(IfcGeom::Material self) -> Material
        """
        this = _ifcopenshell_wrapper.new_Material(style)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hasDiffuse(self):
        """hasDiffuse(Material self) -> bool"""
        return _ifcopenshell_wrapper.Material_hasDiffuse(self)


    def hasSpecular(self):
        """hasSpecular(Material self) -> bool"""
        return _ifcopenshell_wrapper.Material_hasSpecular(self)


    def hasTransparency(self):
        """hasTransparency(Material self) -> bool"""
        return _ifcopenshell_wrapper.Material_hasTransparency(self)


    def hasSpecularity(self):
        """hasSpecularity(Material self) -> bool"""
        return _ifcopenshell_wrapper.Material_hasSpecularity(self)


    def diffuse(self):
        """diffuse(Material self) -> double const *"""
        return _ifcopenshell_wrapper.Material_diffuse(self)


    def specular(self):
        """specular(Material self) -> double const *"""
        return _ifcopenshell_wrapper.Material_specular(self)


    def transparency(self):
        """transparency(Material self) -> double"""
        return _ifcopenshell_wrapper.Material_transparency(self)


    def specularity(self):
        """specularity(Material self) -> double"""
        return _ifcopenshell_wrapper.Material_specularity(self)


    def name(self):
        """name(Material self) -> std::string const &"""
        return _ifcopenshell_wrapper.Material_name(self)


    def original_name(self):
        """original_name(Material self) -> std::string const &"""
        return _ifcopenshell_wrapper.Material_original_name(self)


    def __eq__(self, other):
        """__eq__(Material self, Material other) -> bool"""
        return _ifcopenshell_wrapper.Material___eq__(self, other)


            # Hide the getters with read-only property implementations
    has_diffuse = property(hasDiffuse)
    has_specular = property(hasSpecular)
    has_transparency = property(hasTransparency)
    has_specularity = property(hasSpecularity)
    diffuse = property(diffuse)
    specular = property(specular)
    transparency = property(transparency)
    specularity = property(specularity)
    name = property(name)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_Material
    __del__ = lambda self: None
Material_swigregister = _ifcopenshell_wrapper.Material_swigregister
Material_swigregister(Material)

class Representation(_object):
    """Proxy of C++ IfcGeom::Representation::Representation class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Representation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Representation, name)
    __repr__ = _swig_repr

    def __init__(self, settings):
        """__init__(IfcGeom::Representation::Representation self, ElementSettings settings) -> Representation"""
        this = _ifcopenshell_wrapper.new_Representation(settings)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def settings(self):
        """settings(Representation self) -> ElementSettings"""
        return _ifcopenshell_wrapper.Representation_settings(self)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_Representation
    __del__ = lambda self: None
Representation_swigregister = _ifcopenshell_wrapper.Representation_swigregister
Representation_swigregister(Representation)

class BRep(Representation):
    """Proxy of C++ IfcGeom::Representation::BRep class."""

    __swig_setmethods__ = {}
    for _s in [Representation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRep, name, value)
    __swig_getmethods__ = {}
    for _s in [Representation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRep, name)
    __repr__ = _swig_repr

    def __init__(self, settings, id, shapes):
        """__init__(IfcGeom::Representation::BRep self, ElementSettings settings, std::string const & id, IfcGeom::IfcRepresentationShapeItems const & shapes) -> BRep"""
        this = _ifcopenshell_wrapper.new_BRep(settings, id, shapes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_BRep
    __del__ = lambda self: None

    def begin(self):
        """begin(BRep self) -> IfcGeom::IfcRepresentationShapeItems::const_iterator"""
        return _ifcopenshell_wrapper.BRep_begin(self)


    def end(self):
        """end(BRep self) -> IfcGeom::IfcRepresentationShapeItems::const_iterator"""
        return _ifcopenshell_wrapper.BRep_end(self)


    def shapes(self):
        """shapes(BRep self) -> IfcGeom::IfcRepresentationShapeItems const &"""
        return _ifcopenshell_wrapper.BRep_shapes(self)


    def id(self):
        """id(BRep self) -> std::string const &"""
        return _ifcopenshell_wrapper.BRep_id(self)


    def as_compound(self, force_meters=False):
        """
        as_compound(BRep self, bool force_meters=False) -> TopoDS_Compound
        as_compound(BRep self) -> TopoDS_Compound
        """
        return _ifcopenshell_wrapper.BRep_as_compound(self, force_meters)


    def calculate_volume(self, arg2):
        """calculate_volume(BRep self, double & arg2) -> bool"""
        return _ifcopenshell_wrapper.BRep_calculate_volume(self, arg2)


    def calculate_surface_area(self, arg2):
        """calculate_surface_area(BRep self, double & arg2) -> bool"""
        return _ifcopenshell_wrapper.BRep_calculate_surface_area(self, arg2)


    def calculate_projected_surface_area(self, ax, along_x, along_y, along_z):
        """calculate_projected_surface_area(BRep self, gp_Ax3 const & ax, double & along_x, double & along_y, double & along_z) -> bool"""
        return _ifcopenshell_wrapper.BRep_calculate_projected_surface_area(self, ax, along_x, along_y, along_z)

BRep_swigregister = _ifcopenshell_wrapper.BRep_swigregister
BRep_swigregister(BRep)

class Serialization(Representation):
    """Proxy of C++ IfcGeom::Representation::Serialization class."""

    __swig_setmethods__ = {}
    for _s in [Representation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Serialization, name, value)
    __swig_getmethods__ = {}
    for _s in [Representation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Serialization, name)
    __repr__ = _swig_repr

    def brep_data(self):
        """brep_data(Serialization self) -> std::string const &"""
        return _ifcopenshell_wrapper.Serialization_brep_data(self)


    def surface_styles(self):
        """surface_styles(Serialization self) -> std::vector< double > const &"""
        return _ifcopenshell_wrapper.Serialization_surface_styles(self)


    def surface_style_ids(self):
        """surface_style_ids(Serialization self) -> std::vector< int > const &"""
        return _ifcopenshell_wrapper.Serialization_surface_style_ids(self)


    def __init__(self, brep):
        """__init__(IfcGeom::Representation::Serialization self, BRep brep) -> Serialization"""
        this = _ifcopenshell_wrapper.new_Serialization(brep)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_Serialization
    __del__ = lambda self: None

    def id(self):
        """id(Serialization self) -> std::string const &"""
        return _ifcopenshell_wrapper.Serialization_id(self)


            # Hide the getters with read-only property implementations
    id = property(id)
    brep_data = property(brep_data)
    surface_styles = property(surface_styles)
    surface_style_ids = property(surface_style_ids)

Serialization_swigregister = _ifcopenshell_wrapper.Serialization_swigregister
Serialization_swigregister(Serialization)

class tree(_object):
    """Proxy of C++ IfcGeom::tree class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IfcGeom::tree self) -> tree
        __init__(IfcGeom::tree self, file f) -> tree
        __init__(IfcGeom::tree self, file f, settings settings) -> tree
        """
        this = _ifcopenshell_wrapper.new_tree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add_file(self, f, settings):
        """add_file(tree self, file f, settings settings)"""
        return _ifcopenshell_wrapper.tree_add_file(self, f, settings)


    def vector_to_list(ps):
        """vector_to_list(std::vector< IfcUtil::IfcBaseEntity * > const & ps) -> IfcEntityList::ptr"""
        return _ifcopenshell_wrapper.tree_vector_to_list(ps)

    vector_to_list = staticmethod(vector_to_list)

    def select_box(self, *args):
        """
        select_box(tree self, entity_instance e, bool completely_within=False, double extend=-1.e-5) -> IfcEntityList::ptr
        select_box(tree self, entity_instance e, bool completely_within=False) -> IfcEntityList::ptr
        select_box(tree self, entity_instance e) -> IfcEntityList::ptr
        select_box(tree self, gp_Pnt const & p) -> IfcEntityList::ptr
        select_box(tree self, Bnd_Box const & b, bool completely_within=False) -> IfcEntityList::ptr
        select_box(tree self, Bnd_Box const & b) -> IfcEntityList::ptr
        """
        return _ifcopenshell_wrapper.tree_select_box(self, *args)


    def select(self, *args):
        """
        select(tree self, entity_instance e, bool completely_within=False) -> IfcEntityList::ptr
        select(tree self, entity_instance e) -> IfcEntityList::ptr
        select(tree self, gp_Pnt const & p) -> IfcEntityList::ptr
        select(tree self, std::string const & shape_serialization) -> IfcEntityList::ptr
        """
        return _ifcopenshell_wrapper.tree_select(self, *args)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_tree
    __del__ = lambda self: None
tree_swigregister = _ifcopenshell_wrapper.tree_swigregister
tree_swigregister(tree)

def tree_vector_to_list(ps):
    """tree_vector_to_list(std::vector< IfcUtil::IfcBaseEntity * > const & ps) -> IfcEntityList::ptr"""
    return _ifcopenshell_wrapper.tree_vector_to_list(ps)


def construct_iterator_single_precision_with_include_exclude(settings, file, elems, include, num_threads):
    """construct_iterator_single_precision_with_include_exclude(settings settings, file file, std::vector< std::string > elems, bool include, int num_threads) -> IfcGeom::Iterator< float,float > *"""
    return _ifcopenshell_wrapper.construct_iterator_single_precision_with_include_exclude(settings, file, elems, include, num_threads)

def construct_iterator_double_precision_with_include_exclude(settings, file, elems, include, num_threads):
    """construct_iterator_double_precision_with_include_exclude(settings settings, file file, std::vector< std::string > elems, bool include, int num_threads) -> iterator_double_precision"""
    return _ifcopenshell_wrapper.construct_iterator_double_precision_with_include_exclude(settings, file, elems, include, num_threads)

def construct_iterator_single_precision_with_include_exclude_globalid(settings, file, elems, include, num_threads):
    """construct_iterator_single_precision_with_include_exclude_globalid(settings settings, file file, std::vector< std::string > elems, bool include, int num_threads) -> IfcGeom::Iterator< float,float > *"""
    return _ifcopenshell_wrapper.construct_iterator_single_precision_with_include_exclude_globalid(settings, file, elems, include, num_threads)

def construct_iterator_double_precision_with_include_exclude_globalid(settings, file, elems, include, num_threads):
    """construct_iterator_double_precision_with_include_exclude_globalid(settings settings, file file, std::vector< std::string > elems, bool include, int num_threads) -> iterator_double_precision"""
    return _ifcopenshell_wrapper.construct_iterator_double_precision_with_include_exclude_globalid(settings, file, elems, include, num_threads)

def create_shape(settings, instance, representation=None):
    """
    create_shape(settings settings, entity_instance instance, entity_instance representation=None) -> boost::variant< IfcGeom::Element< double,double > *,IfcGeom::Representation::Representation * >
    create_shape(settings settings, entity_instance instance) -> boost::variant< IfcGeom::Element< double,double > *,IfcGeom::Representation::Representation * >
    """
    return _ifcopenshell_wrapper.create_shape(settings, instance, representation)

def serialise(schema_name, shape_str, advanced=True):
    """
    serialise(std::string const & schema_name, std::string const & shape_str, bool advanced=True) -> entity_instance
    serialise(std::string const & schema_name, std::string const & shape_str) -> entity_instance
    """
    return _ifcopenshell_wrapper.serialise(schema_name, shape_str, advanced)

def tesselate(schema_name, shape_str, d):
    """tesselate(std::string const & schema_name, std::string const & shape_str, double d) -> entity_instance"""
    return _ifcopenshell_wrapper.tesselate(schema_name, shape_str, d)
class iterator_double_precision(_object):
    """Proxy of C++ IfcGeom::Iterator<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, iterator_double_precision, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, iterator_double_precision, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IfcGeom::Iterator<(double)> self, settings settings, file file, int num_threads=1) -> iterator_double_precision
        __init__(IfcGeom::Iterator<(double)> self, settings settings, file file) -> iterator_double_precision
        __init__(IfcGeom::Iterator<(double)> self, settings settings, file file, std::vector< IfcGeom::filter_t > const & filters, size_t num_threads=1) -> iterator_double_precision
        __init__(IfcGeom::Iterator<(double)> self, settings settings, file file, std::vector< IfcGeom::filter_t > const & filters) -> iterator_double_precision
        """
        this = _ifcopenshell_wrapper.new_iterator_double_precision(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def initialize(self):
        """initialize(iterator_double_precision self) -> bool"""
        return _ifcopenshell_wrapper.iterator_double_precision_initialize(self)


    def progress(self):
        """progress(iterator_double_precision self) -> int"""
        return _ifcopenshell_wrapper.iterator_double_precision_progress(self)


    def compute_bounds(self, with_geometry):
        """compute_bounds(iterator_double_precision self, bool with_geometry)"""
        return _ifcopenshell_wrapper.iterator_double_precision_compute_bounds(self, with_geometry)


    def bounds_min(self):
        """bounds_min(iterator_double_precision self) -> gp_XYZ const &"""
        return _ifcopenshell_wrapper.iterator_double_precision_bounds_min(self)


    def bounds_max(self):
        """bounds_max(iterator_double_precision self) -> gp_XYZ const &"""
        return _ifcopenshell_wrapper.iterator_double_precision_bounds_max(self)


    def unit_name(self):
        """unit_name(iterator_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.iterator_double_precision_unit_name(self)


    def unit_magnitude(self):
        """unit_magnitude(iterator_double_precision self) -> double"""
        return _ifcopenshell_wrapper.iterator_double_precision_unit_magnitude(self)


    def file(self):
        """file(iterator_double_precision self) -> file"""
        return _ifcopenshell_wrapper.iterator_double_precision_file(self)


    def next(self):
        """next(iterator_double_precision self) -> entity_instance"""
        return _ifcopenshell_wrapper.iterator_double_precision_next(self)


    def get(self):
        """get(iterator_double_precision self) -> element_double_precision"""
        return _ifcopenshell_wrapper.iterator_double_precision_get(self)


    def get_native(self):
        """get_native(iterator_double_precision self) -> IfcGeom::BRepElement< double,double > *"""
        return _ifcopenshell_wrapper.iterator_double_precision_get_native(self)


    def get_object(self, id):
        """get_object(iterator_double_precision self, int id) -> element_double_precision"""
        return _ifcopenshell_wrapper.iterator_double_precision_get_object(self, id)


    def create(self):
        """create(iterator_double_precision self) -> entity_instance"""
        return _ifcopenshell_wrapper.iterator_double_precision_create(self)


    def mantissa_size():
        """mantissa_size() -> int"""
        return _ifcopenshell_wrapper.iterator_double_precision_mantissa_size()

    mantissa_size = staticmethod(mantissa_size)
    __swig_destroy__ = _ifcopenshell_wrapper.delete_iterator_double_precision
    __del__ = lambda self: None
iterator_double_precision_swigregister = _ifcopenshell_wrapper.iterator_double_precision_swigregister
iterator_double_precision_swigregister(iterator_double_precision)

def iterator_double_precision_mantissa_size():
    """iterator_double_precision_mantissa_size() -> int"""
    return _ifcopenshell_wrapper.iterator_double_precision_mantissa_size()

class element_double_precision(_object):
    """Proxy of C++ IfcGeom::Element<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, element_double_precision, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, element_double_precision, name)
    __repr__ = _swig_repr

    def id(self):
        """id(element_double_precision self) -> int"""
        return _ifcopenshell_wrapper.element_double_precision_id(self)


    def parent_id(self):
        """parent_id(element_double_precision self) -> int"""
        return _ifcopenshell_wrapper.element_double_precision_parent_id(self)


    def name(self):
        """name(element_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.element_double_precision_name(self)


    def type(self):
        """type(element_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.element_double_precision_type(self)


    def guid(self):
        """guid(element_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.element_double_precision_guid(self)


    def context(self):
        """context(element_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.element_double_precision_context(self)


    def unique_id(self):
        """unique_id(element_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.element_double_precision_unique_id(self)


    def transformation(self):
        """transformation(element_double_precision self) -> transformation_double_precision"""
        return _ifcopenshell_wrapper.element_double_precision_transformation(self)


    def product(self):
        """product(element_double_precision self) -> IfcBaseEntity"""
        return _ifcopenshell_wrapper.element_double_precision_product(self)


    def parents(self):
        """parents(element_double_precision self) -> std::vector< IfcGeom::Element< double,double > const * > const"""
        return _ifcopenshell_wrapper.element_double_precision_parents(self)


    def SetParents(self, newparents):
        """SetParents(element_double_precision self, std::vector< IfcGeom::Element< double,double > const * > newparents)"""
        return _ifcopenshell_wrapper.element_double_precision_SetParents(self, newparents)


    def __init__(self, settings, id, parent_id, name, type, guid, context, trsf, product):
        """__init__(IfcGeom::Element<(double)> self, ElementSettings settings, int id, int parent_id, std::string const & name, std::string const & type, std::string const & guid, std::string const & context, gp_Trsf const & trsf, IfcBaseEntity product) -> element_double_precision"""
        this = _ifcopenshell_wrapper.new_element_double_precision(settings, id, parent_id, name, type, guid, context, trsf, product)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_element_double_precision
    __del__ = lambda self: None

    def product_(self):
        """product_(element_double_precision self) -> entity_instance"""
        return _ifcopenshell_wrapper.element_double_precision_product_(self)


            # Hide the getters with read-only property implementations
    id = property(id)
    parent_id = property(parent_id)
    name = property(name)
    type = property(type)
    guid = property(guid)
    context = property(context)
    unique_id = property(unique_id)
    transformation = property(transformation)
    product = property(product_)

element_double_precision_swigregister = _ifcopenshell_wrapper.element_double_precision_swigregister
element_double_precision_swigregister(element_double_precision)

def __eq__(*args):
    """
    __eq__(Element< P,PP > const & element1, Element< P,PP > const & element2) -> bool
    __eq__(element_double_precision element1, element_double_precision element2) -> bool
    """
    return _ifcopenshell_wrapper.__eq__(*args)

def __lt__(*args):
    """
    __lt__(Element< P,PP > const & element1, Element< P,PP > const & element2) -> bool
    __lt__(element_double_precision element1, element_double_precision element2) -> bool
    """
    return _ifcopenshell_wrapper.__lt__(*args)

class triangulation_element_double_precision(element_double_precision):
    """Proxy of C++ IfcGeom::TriangulationElement<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [element_double_precision]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, triangulation_element_double_precision, name, value)
    __swig_getmethods__ = {}
    for _s in [element_double_precision]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, triangulation_element_double_precision, name)
    __repr__ = _swig_repr

    def geometry(self):
        """geometry(triangulation_element_double_precision self) -> triangulation_double_precision"""
        return _ifcopenshell_wrapper.triangulation_element_double_precision_geometry(self)


    def geometry_pointer(self):
        """geometry_pointer(triangulation_element_double_precision self) -> boost::shared_ptr< IfcGeom::Representation::Triangulation< double > > const &"""
        return _ifcopenshell_wrapper.triangulation_element_double_precision_geometry_pointer(self)


    def __init__(self, *args):
        """
        __init__(IfcGeom::TriangulationElement<(double)> self, IfcGeom::BRepElement< double,double > const & shape_model) -> triangulation_element_double_precision
        __init__(IfcGeom::TriangulationElement<(double)> self, element_double_precision element, boost::shared_ptr< IfcGeom::Representation::Triangulation< double > > const & geometry) -> triangulation_element_double_precision
        """
        this = _ifcopenshell_wrapper.new_triangulation_element_double_precision(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

            # Hide the getters with read-only property implementations
    geometry = property(geometry)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_triangulation_element_double_precision
    __del__ = lambda self: None
triangulation_element_double_precision_swigregister = _ifcopenshell_wrapper.triangulation_element_double_precision_swigregister
triangulation_element_double_precision_swigregister(triangulation_element_double_precision)

class serialized_element_double_precision(element_double_precision):
    """Proxy of C++ IfcGeom::SerializedElement<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [element_double_precision]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, serialized_element_double_precision, name, value)
    __swig_getmethods__ = {}
    for _s in [element_double_precision]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, serialized_element_double_precision, name)
    __repr__ = _swig_repr

    def geometry(self):
        """geometry(serialized_element_double_precision self) -> Serialization"""
        return _ifcopenshell_wrapper.serialized_element_double_precision_geometry(self)


    def __init__(self, shape_model):
        """__init__(IfcGeom::SerializedElement<(double)> self, IfcGeom::BRepElement< double,double > const & shape_model) -> serialized_element_double_precision"""
        this = _ifcopenshell_wrapper.new_serialized_element_double_precision(shape_model)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_serialized_element_double_precision
    __del__ = lambda self: None

            # Hide the getters with read-only property implementations
    geometry = property(geometry)

serialized_element_double_precision_swigregister = _ifcopenshell_wrapper.serialized_element_double_precision_swigregister
serialized_element_double_precision_swigregister(serialized_element_double_precision)

class transformation_double_precision(_object):
    """Proxy of C++ IfcGeom::Transformation<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, transformation_double_precision, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, transformation_double_precision, name)
    __repr__ = _swig_repr

    def __init__(self, settings, trsf):
        """__init__(IfcGeom::Transformation<(double)> self, ElementSettings settings, gp_Trsf const & trsf) -> transformation_double_precision"""
        this = _ifcopenshell_wrapper.new_transformation_double_precision(settings, trsf)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data(self):
        """data(transformation_double_precision self) -> gp_Trsf const &"""
        return _ifcopenshell_wrapper.transformation_double_precision_data(self)


    def matrix(self):
        """matrix(transformation_double_precision self) -> matrix_double_precision"""
        return _ifcopenshell_wrapper.transformation_double_precision_matrix(self)


    def inverted(self):
        """inverted(transformation_double_precision self) -> transformation_double_precision"""
        return _ifcopenshell_wrapper.transformation_double_precision_inverted(self)


    def multiplied(self, other):
        """multiplied(transformation_double_precision self, transformation_double_precision other) -> transformation_double_precision"""
        return _ifcopenshell_wrapper.transformation_double_precision_multiplied(self, other)


            # Hide the getters with read-only property implementations
    matrix = property(matrix)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_transformation_double_precision
    __del__ = lambda self: None
transformation_double_precision_swigregister = _ifcopenshell_wrapper.transformation_double_precision_swigregister
transformation_double_precision_swigregister(transformation_double_precision)

class matrix_double_precision(_object):
    """Proxy of C++ IfcGeom::Matrix<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, matrix_double_precision, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, matrix_double_precision, name)
    __repr__ = _swig_repr

    def __init__(self, settings, trsf):
        """__init__(IfcGeom::Matrix<(double)> self, ElementSettings settings, gp_Trsf const & trsf) -> matrix_double_precision"""
        this = _ifcopenshell_wrapper.new_matrix_double_precision(settings, trsf)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data(self):
        """data(matrix_double_precision self) -> std::vector< double > const &"""
        return _ifcopenshell_wrapper.matrix_double_precision_data(self)


            # Hide the getters with read-only property implementations
    data = property(data)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_matrix_double_precision
    __del__ = lambda self: None
matrix_double_precision_swigregister = _ifcopenshell_wrapper.matrix_double_precision_swigregister
matrix_double_precision_swigregister(matrix_double_precision)

class triangulation_double_precision(Representation):
    """Proxy of C++ IfcGeom::Representation::Triangulation<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [Representation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, triangulation_double_precision, name, value)
    __swig_getmethods__ = {}
    for _s in [Representation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, triangulation_double_precision, name)
    __repr__ = _swig_repr

    def id(self):
        """id(triangulation_double_precision self) -> std::string const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_id(self)


    def verts(self):
        """verts(triangulation_double_precision self) -> std::vector< double > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_verts(self)


    def faces(self):
        """faces(triangulation_double_precision self) -> std::vector< int > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_faces(self)


    def edges(self):
        """edges(triangulation_double_precision self) -> std::vector< int > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_edges(self)


    def normals(self):
        """normals(triangulation_double_precision self) -> std::vector< double > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_normals(self)


    def uvs(self):
        """uvs(triangulation_double_precision self) -> std::vector< double > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_uvs(self)


    def material_ids(self):
        """material_ids(triangulation_double_precision self) -> std::vector< int > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_material_ids(self)


    def materials(self):
        """materials(triangulation_double_precision self) -> std::vector< IfcGeom::Material > const &"""
        return _ifcopenshell_wrapper.triangulation_double_precision_materials(self)


    def __init__(self, shape_model):
        """__init__(IfcGeom::Representation::Triangulation<(double)> self, BRep shape_model) -> triangulation_double_precision"""
        this = _ifcopenshell_wrapper.new_triangulation_double_precision(shape_model)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_triangulation_double_precision
    __del__ = lambda self: None

    def box_project_uvs(vertices, normals):
        """box_project_uvs(std::vector< double > const & vertices, std::vector< double > const & normals) -> std::vector< double >"""
        return _ifcopenshell_wrapper.triangulation_double_precision_box_project_uvs(vertices, normals)

    box_project_uvs = staticmethod(box_project_uvs)

            # Hide the getters with read-only property implementations
    id = property(id)
    faces = property(faces)
    edges = property(edges)
    material_ids = property(material_ids)
    materials = property(materials)


            # Hide the getters with read-only property implementations
    verts = property(verts)
    normals = property(normals)

triangulation_double_precision_swigregister = _ifcopenshell_wrapper.triangulation_double_precision_swigregister
triangulation_double_precision_swigregister(triangulation_double_precision)

def triangulation_double_precision_box_project_uvs(vertices, normals):
    """triangulation_double_precision_box_project_uvs(std::vector< double > const & vertices, std::vector< double > const & normals) -> std::vector< double >"""
    return _ifcopenshell_wrapper.triangulation_double_precision_box_project_uvs(vertices, normals)

class IfcEntityInstanceData(_object):
    """Proxy of C++ IfcEntityInstanceData class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IfcEntityInstanceData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IfcEntityInstanceData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ifcopenshell_wrapper.delete_IfcEntityInstanceData
    __del__ = lambda self: None
IfcEntityInstanceData_swigregister = _ifcopenshell_wrapper.IfcEntityInstanceData_swigregister
IfcEntityInstanceData_swigregister(IfcEntityInstanceData)

class HeaderEntity(IfcEntityInstanceData):
    """Proxy of C++ IfcParse::HeaderEntity class."""

    __swig_setmethods__ = {}
    for _s in [IfcEntityInstanceData]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HeaderEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [IfcEntityInstanceData]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HeaderEntity, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getArgumentCount(self):
        """getArgumentCount(HeaderEntity self) -> unsigned int"""
        return _ifcopenshell_wrapper.HeaderEntity_getArgumentCount(self)


    def toString(self, upper=False):
        """
        toString(HeaderEntity self, bool upper=False) -> std::string
        toString(HeaderEntity self) -> std::string
        """
        return _ifcopenshell_wrapper.HeaderEntity_toString(self, upper)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_HeaderEntity
    __del__ = lambda self: None
HeaderEntity_swigregister = _ifcopenshell_wrapper.HeaderEntity_swigregister
HeaderEntity_swigregister(HeaderEntity)

class FileDescription(HeaderEntity):
    """Proxy of C++ IfcParse::FileDescription class."""

    __swig_setmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileDescription, name, value)
    __swig_getmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileDescription, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def description(self, *args):
        """
        description(FileDescription self) -> std::vector< std::string >
        description(FileDescription self, std::vector< std::string > const & value)
        """
        return _ifcopenshell_wrapper.FileDescription_description(self, *args)


    def implementation_level(self, *args):
        """
        implementation_level(FileDescription self) -> std::string
        implementation_level(FileDescription self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileDescription_implementation_level(self, *args)


            # Hide the getters with read-write property implementations
    description = property(description, description)
    implementation_level = property(implementation_level, implementation_level)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_FileDescription
    __del__ = lambda self: None
FileDescription_swigregister = _ifcopenshell_wrapper.FileDescription_swigregister
FileDescription_swigregister(FileDescription)

class FileName(HeaderEntity):
    """Proxy of C++ IfcParse::FileName class."""

    __swig_setmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileName, name, value)
    __swig_getmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileName, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def name(self, *args):
        """
        name(FileName self) -> std::string
        name(FileName self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileName_name(self, *args)


    def time_stamp(self, *args):
        """
        time_stamp(FileName self) -> std::string
        time_stamp(FileName self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileName_time_stamp(self, *args)


    def author(self, *args):
        """
        author(FileName self) -> std::vector< std::string >
        author(FileName self, std::vector< std::string > const & value)
        """
        return _ifcopenshell_wrapper.FileName_author(self, *args)


    def organization(self, *args):
        """
        organization(FileName self) -> std::vector< std::string >
        organization(FileName self, std::vector< std::string > const & value)
        """
        return _ifcopenshell_wrapper.FileName_organization(self, *args)


    def preprocessor_version(self, *args):
        """
        preprocessor_version(FileName self) -> std::string
        preprocessor_version(FileName self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileName_preprocessor_version(self, *args)


    def originating_system(self, *args):
        """
        originating_system(FileName self) -> std::string
        originating_system(FileName self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileName_originating_system(self, *args)


    def authorization(self, *args):
        """
        authorization(FileName self) -> std::string
        authorization(FileName self, std::string const & value)
        """
        return _ifcopenshell_wrapper.FileName_authorization(self, *args)


    name = property(name, name)
    time_stamp = property(time_stamp, time_stamp)
    author = property(author, author)
    organization = property(organization, organization)
    preprocessor_version = property(preprocessor_version, preprocessor_version)
    originating_system = property(originating_system, originating_system)
    authorization = property(authorization, authorization)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_FileName
    __del__ = lambda self: None
FileName_swigregister = _ifcopenshell_wrapper.FileName_swigregister
FileName_swigregister(FileName)

class FileSchema(HeaderEntity):
    """Proxy of C++ IfcParse::FileSchema class."""

    __swig_setmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileSchema, name, value)
    __swig_getmethods__ = {}
    for _s in [HeaderEntity]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileSchema, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def schema_identifiers(self, *args):
        """
        schema_identifiers(FileSchema self) -> std::vector< std::string >
        schema_identifiers(FileSchema self, std::vector< std::string > const & value)
        """
        return _ifcopenshell_wrapper.FileSchema_schema_identifiers(self, *args)


            # Hide the getters with read-write property implementations
    schema_identifiers = property(schema_identifiers, schema_identifiers)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_FileSchema
    __del__ = lambda self: None
FileSchema_swigregister = _ifcopenshell_wrapper.FileSchema_swigregister
FileSchema_swigregister(FileSchema)

class IfcSpfHeader(_object):
    """Proxy of C++ IfcParse::IfcSpfHeader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IfcSpfHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IfcSpfHeader, name)
    __repr__ = _swig_repr

    def __init__(self, file=None):
        """
        __init__(IfcParse::IfcSpfHeader self, file file=None) -> IfcSpfHeader
        __init__(IfcParse::IfcSpfHeader self) -> IfcSpfHeader
        """
        this = _ifcopenshell_wrapper.new_IfcSpfHeader(file)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_IfcSpfHeader
    __del__ = lambda self: None

    def file(self, *args):
        """
        file(IfcSpfHeader self) -> file
        file(IfcSpfHeader self, file file)
        """
        return _ifcopenshell_wrapper.IfcSpfHeader_file(self, *args)


    def read(self):
        """read(IfcSpfHeader self)"""
        return _ifcopenshell_wrapper.IfcSpfHeader_read(self)


    def tryRead(self):
        """tryRead(IfcSpfHeader self) -> bool"""
        return _ifcopenshell_wrapper.IfcSpfHeader_tryRead(self)


    def write(self, os):
        """write(IfcSpfHeader self, std::ostream & os)"""
        return _ifcopenshell_wrapper.IfcSpfHeader_write(self, os)


    def file_description(self, *args):
        """
        file_description(IfcSpfHeader self) -> FileDescription
        file_description(IfcSpfHeader self) -> FileDescription
        """
        return _ifcopenshell_wrapper.IfcSpfHeader_file_description(self, *args)


    def file_name(self, *args):
        """
        file_name(IfcSpfHeader self) -> FileName
        file_name(IfcSpfHeader self) -> FileName
        """
        return _ifcopenshell_wrapper.IfcSpfHeader_file_name(self, *args)


    def file_schema(self, *args):
        """
        file_schema(IfcSpfHeader self) -> FileSchema
        file_schema(IfcSpfHeader self) -> FileSchema
        """
        return _ifcopenshell_wrapper.IfcSpfHeader_file_schema(self, *args)


            # Hide the getters with read-only property implementations
    file_description = property(file_description)
    file_name = property(file_name)
    file_schema = property(file_schema)

IfcSpfHeader_swigregister = _ifcopenshell_wrapper.IfcSpfHeader_swigregister
IfcSpfHeader_swigregister(IfcSpfHeader)

class file_open_status(_object):
    """Proxy of C++ IfcParse::file_open_status class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, file_open_status, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, file_open_status, name)
    __repr__ = _swig_repr
    SUCCESS = _ifcopenshell_wrapper.file_open_status_SUCCESS
    READ_ERROR = _ifcopenshell_wrapper.file_open_status_READ_ERROR
    NO_HEADER = _ifcopenshell_wrapper.file_open_status_NO_HEADER
    UNSUPPORTED_SCHEMA = _ifcopenshell_wrapper.file_open_status_UNSUPPORTED_SCHEMA

    def __init__(self, error):
        """__init__(IfcParse::file_open_status self, IfcParse::file_open_status::file_open_enum error) -> file_open_status"""
        this = _ifcopenshell_wrapper.new_file_open_status(error)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        """value(file_open_status self) -> IfcParse::file_open_status::file_open_enum"""
        return _ifcopenshell_wrapper.file_open_status_value(self)


    def __nonzero__(self):
        return _ifcopenshell_wrapper.file_open_status___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _ifcopenshell_wrapper.delete_file_open_status
    __del__ = lambda self: None
file_open_status_swigregister = _ifcopenshell_wrapper.file_open_status_swigregister
file_open_status_swigregister(file_open_status)

class file(_object):
    """Proxy of C++ IfcParse::IfcFile class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, file, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, file, name)
    __repr__ = _swig_repr
    __swig_setmethods__["stream"] = _ifcopenshell_wrapper.file_stream_set
    __swig_getmethods__["stream"] = _ifcopenshell_wrapper.file_stream_get
    if _newclass:
        stream = _swig_property(_ifcopenshell_wrapper.file_stream_get, _ifcopenshell_wrapper.file_stream_set)

    def __init__(self, *args):
        """
        __init__(IfcParse::IfcFile self, std::string const & fn) -> file
        __init__(IfcParse::IfcFile self, std::istream & fn, int len) -> file
        __init__(IfcParse::IfcFile self, void * data, int len) -> file
        __init__(IfcParse::IfcFile self, IfcParse::IfcSpfStream * f) -> file
        __init__(IfcParse::IfcFile self, schema_definition schema) -> file
        __init__(IfcParse::IfcFile self) -> file
        """
        this = _ifcopenshell_wrapper.new_file(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_file
    __del__ = lambda self: None

    def good(self):
        """good(file self) -> file_open_status"""
        return _ifcopenshell_wrapper.file_good(self)


    def types_begin(self):
        """types_begin(file self) -> IfcParse::IfcFile::type_iterator"""
        return _ifcopenshell_wrapper.file_types_begin(self)


    def types_end(self):
        """types_end(file self) -> IfcParse::IfcFile::type_iterator"""
        return _ifcopenshell_wrapper.file_types_end(self)


    def types_incl_super_begin(self):
        """types_incl_super_begin(file self) -> IfcParse::IfcFile::type_iterator"""
        return _ifcopenshell_wrapper.file_types_incl_super_begin(self)


    def types_incl_super_end(self):
        """types_incl_super_end(file self) -> IfcParse::IfcFile::type_iterator"""
        return _ifcopenshell_wrapper.file_types_incl_super_end(self)


    def by_type(self, *args):
        """
        by_type(file self, declaration arg2) -> IfcEntityList::ptr
        by_type(file self, std::string const & t) -> IfcEntityList::ptr
        """
        return _ifcopenshell_wrapper.file_by_type(self, *args)


    def by_type_excl_subtypes(self, *args):
        """
        by_type_excl_subtypes(file self, declaration arg2) -> IfcEntityList::ptr
        by_type_excl_subtypes(file self, std::string const & t) -> IfcEntityList::ptr
        """
        return _ifcopenshell_wrapper.file_by_type_excl_subtypes(self, *args)


    def instances_by_reference(self, id):
        """instances_by_reference(file self, int id) -> IfcEntityList::ptr"""
        return _ifcopenshell_wrapper.file_instances_by_reference(self, id)


    def by_id(self, id):
        """by_id(file self, int id) -> entity_instance"""
        return _ifcopenshell_wrapper.file_by_id(self, id)


    def instance_by_guid(self, guid):
        """instance_by_guid(file self, std::string const & guid) -> entity_instance"""
        return _ifcopenshell_wrapper.file_instance_by_guid(self, guid)


    def traverse(self, instance, max_level=-1):
        """
        traverse(file self, entity_instance instance, int max_level=-1) -> IfcEntityList::ptr
        traverse(file self, entity_instance instance) -> IfcEntityList::ptr
        """
        return _ifcopenshell_wrapper.file_traverse(self, instance, max_level)


    def getInverse(self, instance_id, type, attribute_index):
        """getInverse(file self, int instance_id, declaration type, int attribute_index) -> IfcEntityList::ptr"""
        return _ifcopenshell_wrapper.file_getInverse(self, instance_id, type, attribute_index)


    def mark_entity_as_modified(self, id):
        """mark_entity_as_modified(file self, int id)"""
        return _ifcopenshell_wrapper.file_mark_entity_as_modified(self, id)


    def FreshId(self):
        """FreshId(file self) -> unsigned int"""
        return _ifcopenshell_wrapper.file_FreshId(self)


    def add(self, entity):
        """add(file self, entity_instance entity) -> entity_instance"""
        return _ifcopenshell_wrapper.file_add(self, entity)


    def addEntities(self, es):
        """addEntities(file self, IfcEntityList::ptr es)"""
        return _ifcopenshell_wrapper.file_addEntities(self, es)


    def remove(self, entity):
        """remove(file self, entity_instance entity)"""
        return _ifcopenshell_wrapper.file_remove(self, entity)


    def header(self, *args):
        """
        header(file self) -> IfcSpfHeader
        header(file self) -> IfcSpfHeader
        """
        return _ifcopenshell_wrapper.file_header(self, *args)


    def createTimestamp(self):
        """createTimestamp(file self) -> std::string"""
        return _ifcopenshell_wrapper.file_createTimestamp(self)


    def load(self, entity_instance_name, attributes, num_attributes):
        """load(file self, unsigned int entity_instance_name, Argument **& attributes, size_t num_attributes) -> size_t"""
        return _ifcopenshell_wrapper.file_load(self, entity_instance_name, attributes, num_attributes)


    def seek_to(self, data):
        """seek_to(file self, IfcEntityInstanceData data)"""
        return _ifcopenshell_wrapper.file_seek_to(self, data)


    def try_read_semicolon(self):
        """try_read_semicolon(file self)"""
        return _ifcopenshell_wrapper.file_try_read_semicolon(self)


    def getUnit(self, unit_type):
        """getUnit(file self, std::string const & unit_type) -> std::pair< IfcUtil::IfcBaseClass *,double >"""
        return _ifcopenshell_wrapper.file_getUnit(self, unit_type)


    def parsing_complete(self, *args):
        """
        parsing_complete(file self) -> bool
        parsing_complete(file self) -> bool &
        """
        return _ifcopenshell_wrapper.file_parsing_complete(self, *args)


    def build_inverses(self):
        """build_inverses(file self)"""
        return _ifcopenshell_wrapper.file_build_inverses(self)


    def by_guid(self, guid):
        """by_guid(file self, std::string const & guid) -> entity_instance"""
        return _ifcopenshell_wrapper.file_by_guid(self, guid)


    def get_inverse(self, e):
        """get_inverse(file self, entity_instance e) -> IfcEntityList::ptr"""
        return _ifcopenshell_wrapper.file_get_inverse(self, e)


    def write(self, fn):
        """write(file self, std::string const & fn)"""
        return _ifcopenshell_wrapper.file_write(self, fn)


    def to_string(self):
        """to_string(file self) -> std::string"""
        return _ifcopenshell_wrapper.file_to_string(self)


    def entity_names(self):
        """entity_names(file self) -> std::vector< unsigned int >"""
        return _ifcopenshell_wrapper.file_entity_names(self)


    def types(self):
        """types(file self) -> std::vector< std::string >"""
        return _ifcopenshell_wrapper.file_types(self)


    def types_with_super(self):
        """types_with_super(file self) -> std::vector< std::string >"""
        return _ifcopenshell_wrapper.file_types_with_super(self)


    def schema_name(self):
        """schema_name(file self) -> std::string"""
        return _ifcopenshell_wrapper.file_schema_name(self)


            # Hide the getters with read-only property implementations
    header = property(header)
    schema = property(schema_name)

file_swigregister = _ifcopenshell_wrapper.file_swigregister
file_swigregister(file)

class entity_instance(_object):
    """Proxy of C++ IfcUtil::IfcBaseClass class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, entity_instance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, entity_instance, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _ifcopenshell_wrapper.delete_entity_instance
    __del__ = lambda self: None

    def data(self, *args):
        """
        data(entity_instance self) -> IfcEntityInstanceData
        data(entity_instance self) -> IfcEntityInstanceData
        data(entity_instance self, IfcEntityInstanceData d)
        """
        return _ifcopenshell_wrapper.entity_instance_data(self, *args)


    def declaration(self):
        """declaration(entity_instance self) -> declaration"""
        return _ifcopenshell_wrapper.entity_instance_declaration(self)


    def get_attribute_category(self, name):
        """get_attribute_category(entity_instance self, std::string const & name) -> int"""
        return _ifcopenshell_wrapper.entity_instance_get_attribute_category(self, name)


    def id(self):
        """id(entity_instance self) -> int"""
        return _ifcopenshell_wrapper.entity_instance_id(self)


    def __len__(self):
        """__len__(entity_instance self) -> int"""
        return _ifcopenshell_wrapper.entity_instance___len__(self)


    def get_attribute_names(self):
        """get_attribute_names(entity_instance self) -> std::vector< std::string >"""
        return _ifcopenshell_wrapper.entity_instance_get_attribute_names(self)


    def get_inverse_attribute_names(self):
        """get_inverse_attribute_names(entity_instance self) -> std::vector< std::string >"""
        return _ifcopenshell_wrapper.entity_instance_get_inverse_attribute_names(self)


    def is_a(self, *args):
        """
        is_a(entity_instance self, std::string const & s) -> bool
        is_a(entity_instance self) -> std::string
        """
        return _ifcopenshell_wrapper.entity_instance_is_a(self, *args)


    def get_argument(self, *args):
        """
        get_argument(entity_instance self, unsigned int i) -> std::pair< IfcUtil::ArgumentType,Argument * >
        get_argument(entity_instance self, std::string const & a) -> std::pair< IfcUtil::ArgumentType,Argument * >
        """
        return _ifcopenshell_wrapper.entity_instance_get_argument(self, *args)


    def __eq__(self, other):
        """__eq__(entity_instance self, entity_instance other) -> bool"""
        return _ifcopenshell_wrapper.entity_instance___eq__(self, other)


    def __repr__(self):
        """__repr__(entity_instance self) -> std::string"""
        return _ifcopenshell_wrapper.entity_instance___repr__(self)


    def file_pointer(self):
        """file_pointer(entity_instance self) -> size_t"""
        return _ifcopenshell_wrapper.entity_instance_file_pointer(self)


    def get_argument_index(self, a):
        """get_argument_index(entity_instance self, std::string const & a) -> unsigned int"""
        return _ifcopenshell_wrapper.entity_instance_get_argument_index(self, a)


    def get_inverse(self, a):
        """get_inverse(entity_instance self, std::string const & a) -> IfcEntityList::ptr"""
        return _ifcopenshell_wrapper.entity_instance_get_inverse(self, a)


    def get_argument_type(self, i):
        """get_argument_type(entity_instance self, unsigned int i) -> char const *const"""
        return _ifcopenshell_wrapper.entity_instance_get_argument_type(self, i)


    def get_argument_name(self, i):
        """get_argument_name(entity_instance self, unsigned int i) -> std::string const &"""
        return _ifcopenshell_wrapper.entity_instance_get_argument_name(self, i)


    def setArgumentAsNull(self, i):
        """setArgumentAsNull(entity_instance self, unsigned int i)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsNull(self, i)


    def setArgumentAsInt(self, i, v):
        """setArgumentAsInt(entity_instance self, unsigned int i, int v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsInt(self, i, v)


    def setArgumentAsBool(self, i, v):
        """setArgumentAsBool(entity_instance self, unsigned int i, bool v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsBool(self, i, v)


    def setArgumentAsDouble(self, i, v):
        """setArgumentAsDouble(entity_instance self, unsigned int i, double v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsDouble(self, i, v)


    def setArgumentAsString(self, i, a):
        """setArgumentAsString(entity_instance self, unsigned int i, std::string const & a)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsString(self, i, a)


    def setArgumentAsAggregateOfInt(self, i, v):
        """setArgumentAsAggregateOfInt(entity_instance self, unsigned int i, std::vector< int > const & v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfInt(self, i, v)


    def setArgumentAsAggregateOfDouble(self, i, v):
        """setArgumentAsAggregateOfDouble(entity_instance self, unsigned int i, std::vector< double > const & v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfDouble(self, i, v)


    def setArgumentAsAggregateOfString(self, i, v):
        """setArgumentAsAggregateOfString(entity_instance self, unsigned int i, std::vector< std::string > const & v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfString(self, i, v)


    def setArgumentAsEntityInstance(self, i, v):
        """setArgumentAsEntityInstance(entity_instance self, unsigned int i, entity_instance v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsEntityInstance(self, i, v)


    def setArgumentAsAggregateOfEntityInstance(self, i, v):
        """setArgumentAsAggregateOfEntityInstance(entity_instance self, unsigned int i, IfcEntityList::ptr v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfEntityInstance(self, i, v)


    def setArgumentAsAggregateOfAggregateOfInt(self, i, v):
        """setArgumentAsAggregateOfAggregateOfInt(entity_instance self, unsigned int i, std::vector< std::vector< int > > const & v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfAggregateOfInt(self, i, v)


    def setArgumentAsAggregateOfAggregateOfDouble(self, i, v):
        """setArgumentAsAggregateOfAggregateOfDouble(entity_instance self, unsigned int i, std::vector< std::vector< double > > const & v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfAggregateOfDouble(self, i, v)


    def setArgumentAsAggregateOfAggregateOfEntityInstance(self, i, v):
        """setArgumentAsAggregateOfAggregateOfEntityInstance(entity_instance self, unsigned int i, IfcEntityListList::ptr v)"""
        return _ifcopenshell_wrapper.entity_instance_setArgumentAsAggregateOfAggregateOfEntityInstance(self, i, v)

entity_instance_swigregister = _ifcopenshell_wrapper.entity_instance_swigregister
entity_instance_swigregister(entity_instance)

class IfcLateBoundEntity(entity_instance):
    """Proxy of C++ IfcUtil::IfcLateBoundEntity class."""

    __swig_setmethods__ = {}
    for _s in [entity_instance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IfcLateBoundEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [entity_instance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IfcLateBoundEntity, name)
    __repr__ = _swig_repr

    def __init__(self, decl, data):
        """__init__(IfcUtil::IfcLateBoundEntity self, declaration decl, IfcEntityInstanceData data) -> IfcLateBoundEntity"""
        this = _ifcopenshell_wrapper.new_IfcLateBoundEntity(decl, data)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def declaration(self):
        """declaration(IfcLateBoundEntity self) -> declaration"""
        return _ifcopenshell_wrapper.IfcLateBoundEntity_declaration(self)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_IfcLateBoundEntity
    __del__ = lambda self: None
IfcLateBoundEntity_swigregister = _ifcopenshell_wrapper.IfcLateBoundEntity_swigregister
IfcLateBoundEntity_swigregister(IfcLateBoundEntity)

class IfcBaseEntity(entity_instance):
    """Proxy of C++ IfcUtil::IfcBaseEntity class."""

    __swig_setmethods__ = {}
    for _s in [entity_instance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IfcBaseEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [entity_instance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IfcBaseEntity, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def declaration(self):
        """declaration(IfcBaseEntity self) -> entity"""
        return _ifcopenshell_wrapper.IfcBaseEntity_declaration(self)


    def get(self, name):
        """get(IfcBaseEntity self, std::string const & name) -> Argument *"""
        return _ifcopenshell_wrapper.IfcBaseEntity_get(self, name)


    def get_inverse(self, a):
        """get_inverse(IfcBaseEntity self, std::string const & a) -> boost::shared_ptr< IfcEntityList >"""
        return _ifcopenshell_wrapper.IfcBaseEntity_get_inverse(self, a)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_IfcBaseEntity
    __del__ = lambda self: None
IfcBaseEntity_swigregister = _ifcopenshell_wrapper.IfcBaseEntity_swigregister
IfcBaseEntity_swigregister(IfcBaseEntity)

class IfcBaseType(entity_instance):
    """Proxy of C++ IfcUtil::IfcBaseType class."""

    __swig_setmethods__ = {}
    for _s in [entity_instance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IfcBaseType, name, value)
    __swig_getmethods__ = {}
    for _s in [entity_instance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IfcBaseType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def declaration(self):
        """declaration(IfcBaseType self) -> declaration"""
        return _ifcopenshell_wrapper.IfcBaseType_declaration(self)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_IfcBaseType
    __del__ = lambda self: None
IfcBaseType_swigregister = _ifcopenshell_wrapper.IfcBaseType_swigregister
IfcBaseType_swigregister(IfcBaseType)

class parameter_type(_object):
    """Proxy of C++ IfcParse::parameter_type class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, parameter_type, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, parameter_type, name)
    __repr__ = _swig_repr

    def as_named_type(self):
        """as_named_type(parameter_type self) -> named_type"""
        return _ifcopenshell_wrapper.parameter_type_as_named_type(self)


    def as_simple_type(self):
        """as_simple_type(parameter_type self) -> simple_type"""
        return _ifcopenshell_wrapper.parameter_type_as_simple_type(self)


    def as_aggregation_type(self):
        """as_aggregation_type(parameter_type self) -> aggregation_type"""
        return _ifcopenshell_wrapper.parameter_type_as_aggregation_type(self)


    def _is(self, *args):
        """
        _is(parameter_type self, std::string const & arg2) -> bool
        _is(parameter_type self, declaration arg2) -> bool
        """
        return _ifcopenshell_wrapper.parameter_type__is(self, *args)


    def __init__(self):
        """__init__(IfcParse::parameter_type self) -> parameter_type"""
        this = _ifcopenshell_wrapper.new_parameter_type()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_parameter_type
    __del__ = lambda self: None
parameter_type_swigregister = _ifcopenshell_wrapper.parameter_type_swigregister
parameter_type_swigregister(parameter_type)

class named_type(parameter_type):
    """Proxy of C++ IfcParse::named_type class."""

    __swig_setmethods__ = {}
    for _s in [parameter_type]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, named_type, name, value)
    __swig_getmethods__ = {}
    for _s in [parameter_type]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, named_type, name)
    __repr__ = _swig_repr

    def __init__(self, declared_type):
        """__init__(IfcParse::named_type self, declaration declared_type) -> named_type"""
        this = _ifcopenshell_wrapper.new_named_type(declared_type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def declared_type(self):
        """declared_type(named_type self) -> declaration"""
        return _ifcopenshell_wrapper.named_type_declared_type(self)


    def as_named_type(self):
        """as_named_type(named_type self) -> named_type"""
        return _ifcopenshell_wrapper.named_type_as_named_type(self)


    def _is(self, *args):
        """
        _is(named_type self, std::string const & name) -> bool
        _is(named_type self, declaration decl) -> bool
        """
        return _ifcopenshell_wrapper.named_type__is(self, *args)


    def __repr__(self):
    	return repr(self.declared_type())

    __swig_destroy__ = _ifcopenshell_wrapper.delete_named_type
    __del__ = lambda self: None
named_type_swigregister = _ifcopenshell_wrapper.named_type_swigregister
named_type_swigregister(named_type)

class simple_type(parameter_type):
    """Proxy of C++ IfcParse::simple_type class."""

    __swig_setmethods__ = {}
    for _s in [parameter_type]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, simple_type, name, value)
    __swig_getmethods__ = {}
    for _s in [parameter_type]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, simple_type, name)
    __repr__ = _swig_repr
    binary_type = _ifcopenshell_wrapper.simple_type_binary_type
    boolean_type = _ifcopenshell_wrapper.simple_type_boolean_type
    integer_type = _ifcopenshell_wrapper.simple_type_integer_type
    logical_type = _ifcopenshell_wrapper.simple_type_logical_type
    number_type = _ifcopenshell_wrapper.simple_type_number_type
    real_type = _ifcopenshell_wrapper.simple_type_real_type
    string_type = _ifcopenshell_wrapper.simple_type_string_type
    datatype_COUNT = _ifcopenshell_wrapper.simple_type_datatype_COUNT

    def __init__(self, declared_type):
        """__init__(IfcParse::simple_type self, IfcParse::simple_type::data_type declared_type) -> simple_type"""
        this = _ifcopenshell_wrapper.new_simple_type(declared_type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def declared_type(self):
        """declared_type(simple_type self) -> IfcParse::simple_type::data_type"""
        return _ifcopenshell_wrapper.simple_type_declared_type(self)


    def as_simple_type(self):
        """as_simple_type(simple_type self) -> simple_type"""
        return _ifcopenshell_wrapper.simple_type_as_simple_type(self)


    def __repr__(self):
    	return "<%s>" % self.declared_type()

    __swig_destroy__ = _ifcopenshell_wrapper.delete_simple_type
    __del__ = lambda self: None
simple_type_swigregister = _ifcopenshell_wrapper.simple_type_swigregister
simple_type_swigregister(simple_type)

class aggregation_type(parameter_type):
    """Proxy of C++ IfcParse::aggregation_type class."""

    __swig_setmethods__ = {}
    for _s in [parameter_type]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, aggregation_type, name, value)
    __swig_getmethods__ = {}
    for _s in [parameter_type]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, aggregation_type, name)
    __repr__ = _swig_repr
    array_type = _ifcopenshell_wrapper.aggregation_type_array_type
    bag_type = _ifcopenshell_wrapper.aggregation_type_bag_type
    list_type = _ifcopenshell_wrapper.aggregation_type_list_type
    set_type = _ifcopenshell_wrapper.aggregation_type_set_type

    def __init__(self, type_of_aggregation, bound1, bound2, type_of_element):
        """__init__(IfcParse::aggregation_type self, IfcParse::aggregation_type::aggregate_type type_of_aggregation, int bound1, int bound2, parameter_type type_of_element) -> aggregation_type"""
        this = _ifcopenshell_wrapper.new_aggregation_type(type_of_aggregation, bound1, bound2, type_of_element)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def type_of_aggregation(self):
        """type_of_aggregation(aggregation_type self) -> IfcParse::aggregation_type::aggregate_type"""
        return _ifcopenshell_wrapper.aggregation_type_type_of_aggregation(self)


    def bound1(self):
        """bound1(aggregation_type self) -> int"""
        return _ifcopenshell_wrapper.aggregation_type_bound1(self)


    def bound2(self):
        """bound2(aggregation_type self) -> int"""
        return _ifcopenshell_wrapper.aggregation_type_bound2(self)


    def type_of_element(self):
        """type_of_element(aggregation_type self) -> parameter_type"""
        return _ifcopenshell_wrapper.aggregation_type_type_of_element(self)


    def as_aggregation_type(self):
        """as_aggregation_type(aggregation_type self) -> aggregation_type"""
        return _ifcopenshell_wrapper.aggregation_type_as_aggregation_type(self)


    def type_of_aggregation_string(self):
        """type_of_aggregation_string(aggregation_type self) -> std::string"""
        return _ifcopenshell_wrapper.aggregation_type_type_of_aggregation_string(self)


    def __repr__(self):
    	format_bound = lambda i: "?" if i == -1 else str(i)
    	return "<%s [%s:%s] of %r>" % (
    		self.type_of_aggregation_string(),
    		format_bound(self.bound1()),
    		format_bound(self.bound2()),
    		self.type_of_element()
    	)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_aggregation_type
    __del__ = lambda self: None
aggregation_type_swigregister = _ifcopenshell_wrapper.aggregation_type_swigregister
aggregation_type_swigregister(aggregation_type)

class declaration(_object):
    """Proxy of C++ IfcParse::declaration class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, declaration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, declaration, name)
    __repr__ = _swig_repr

    def __init__(self, name, index_in_schema):
        """__init__(IfcParse::declaration self, std::string const & name, int index_in_schema) -> declaration"""
        this = _ifcopenshell_wrapper.new_declaration(name, index_in_schema)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_declaration
    __del__ = lambda self: None

    def name(self):
        """name(declaration self) -> std::string const &"""
        return _ifcopenshell_wrapper.declaration_name(self)


    def name_lc(self):
        """name_lc(declaration self) -> std::string const &"""
        return _ifcopenshell_wrapper.declaration_name_lc(self)


    def as_type_declaration(self):
        """as_type_declaration(declaration self) -> type_declaration"""
        return _ifcopenshell_wrapper.declaration_as_type_declaration(self)


    def as_select_type(self):
        """as_select_type(declaration self) -> select_type"""
        return _ifcopenshell_wrapper.declaration_as_select_type(self)


    def as_enumeration_type(self):
        """as_enumeration_type(declaration self) -> enumeration_type"""
        return _ifcopenshell_wrapper.declaration_as_enumeration_type(self)


    def as_entity(self):
        """as_entity(declaration self) -> entity"""
        return _ifcopenshell_wrapper.declaration_as_entity(self)


    def _is(self, *args):
        """
        _is(declaration self, std::string const & name) -> bool
        _is(declaration self, declaration decl) -> bool
        """
        return _ifcopenshell_wrapper.declaration__is(self, *args)


    def index_in_schema(self):
        """index_in_schema(declaration self) -> int"""
        return _ifcopenshell_wrapper.declaration_index_in_schema(self)


    def type(self):
        """type(declaration self) -> int"""
        return _ifcopenshell_wrapper.declaration_type(self)


    def schema(self):
        """schema(declaration self) -> schema_definition"""
        return _ifcopenshell_wrapper.declaration_schema(self)

declaration_swigregister = _ifcopenshell_wrapper.declaration_swigregister
declaration_swigregister(declaration)

class type_declaration(declaration):
    """Proxy of C++ IfcParse::type_declaration class."""

    __swig_setmethods__ = {}
    for _s in [declaration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, type_declaration, name, value)
    __swig_getmethods__ = {}
    for _s in [declaration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, type_declaration, name)
    __repr__ = _swig_repr

    def __init__(self, name, index_in_schema, declared_type):
        """__init__(IfcParse::type_declaration self, std::string const & name, int index_in_schema, parameter_type declared_type) -> type_declaration"""
        this = _ifcopenshell_wrapper.new_type_declaration(name, index_in_schema, declared_type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def declared_type(self):
        """declared_type(type_declaration self) -> parameter_type"""
        return _ifcopenshell_wrapper.type_declaration_declared_type(self)


    def as_type_declaration(self):
        """as_type_declaration(type_declaration self) -> type_declaration"""
        return _ifcopenshell_wrapper.type_declaration_as_type_declaration(self)


    def __repr__(self):
    	return "<type %s: %r>" % (self.name(), self.declared_type())

    __swig_destroy__ = _ifcopenshell_wrapper.delete_type_declaration
    __del__ = lambda self: None
type_declaration_swigregister = _ifcopenshell_wrapper.type_declaration_swigregister
type_declaration_swigregister(type_declaration)

class select_type(declaration):
    """Proxy of C++ IfcParse::select_type class."""

    __swig_setmethods__ = {}
    for _s in [declaration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, select_type, name, value)
    __swig_getmethods__ = {}
    for _s in [declaration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, select_type, name)
    __repr__ = _swig_repr

    def __init__(self, name, index_in_schema, select_list):
        """__init__(IfcParse::select_type self, std::string const & name, int index_in_schema, std::vector< IfcParse::declaration const * > const & select_list) -> select_type"""
        this = _ifcopenshell_wrapper.new_select_type(name, index_in_schema, select_list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def select_list(self):
        """select_list(select_type self) -> std::vector< IfcParse::declaration const * > const &"""
        return _ifcopenshell_wrapper.select_type_select_list(self)


    def as_select_type(self):
        """as_select_type(select_type self) -> select_type"""
        return _ifcopenshell_wrapper.select_type_as_select_type(self)


    def __repr__(self):
    	return "<select %s: (%s)>" % (self.name(), " | ".join(map(repr, self.select_list())))

    __swig_destroy__ = _ifcopenshell_wrapper.delete_select_type
    __del__ = lambda self: None
select_type_swigregister = _ifcopenshell_wrapper.select_type_swigregister
select_type_swigregister(select_type)

class enumeration_type(declaration):
    """Proxy of C++ IfcParse::enumeration_type class."""

    __swig_setmethods__ = {}
    for _s in [declaration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, enumeration_type, name, value)
    __swig_getmethods__ = {}
    for _s in [declaration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, enumeration_type, name)
    __repr__ = _swig_repr

    def __init__(self, name, index_in_schema, enumeration_items):
        """__init__(IfcParse::enumeration_type self, std::string const & name, int index_in_schema, std::vector< std::string > const & enumeration_items) -> enumeration_type"""
        this = _ifcopenshell_wrapper.new_enumeration_type(name, index_in_schema, enumeration_items)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def enumeration_items(self):
        """enumeration_items(enumeration_type self) -> std::vector< std::string > const &"""
        return _ifcopenshell_wrapper.enumeration_type_enumeration_items(self)


    def as_enumeration_type(self):
        """as_enumeration_type(enumeration_type self) -> enumeration_type"""
        return _ifcopenshell_wrapper.enumeration_type_as_enumeration_type(self)


    def __repr__(self):
    	return "<enumeration %s: (%s)>" % (self.name(), ", ".join(self.enumeration_items()))

    __swig_destroy__ = _ifcopenshell_wrapper.delete_enumeration_type
    __del__ = lambda self: None
enumeration_type_swigregister = _ifcopenshell_wrapper.enumeration_type_swigregister
enumeration_type_swigregister(enumeration_type)

class attribute(_object):
    """Proxy of C++ IfcParse::attribute class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, attribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, attribute, name)
    __repr__ = _swig_repr

    def __init__(self, name, type_of_attribute, optional):
        """__init__(IfcParse::attribute self, std::string const & name, parameter_type type_of_attribute, bool optional) -> attribute"""
        this = _ifcopenshell_wrapper.new_attribute(name, type_of_attribute, optional)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        """name(attribute self) -> std::string const &"""
        return _ifcopenshell_wrapper.attribute_name(self)


    def type_of_attribute(self):
        """type_of_attribute(attribute self) -> parameter_type"""
        return _ifcopenshell_wrapper.attribute_type_of_attribute(self)


    def optional(self):
        """optional(attribute self) -> bool"""
        return _ifcopenshell_wrapper.attribute_optional(self)


    def __repr__(self):
    	return "<attribute %s%s: %s>" % (self.name(), "?" if self.optional() else "", self.type_of_attribute())

    __swig_destroy__ = _ifcopenshell_wrapper.delete_attribute
    __del__ = lambda self: None
attribute_swigregister = _ifcopenshell_wrapper.attribute_swigregister
attribute_swigregister(attribute)

class inverse_attribute(_object):
    """Proxy of C++ IfcParse::inverse_attribute class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, inverse_attribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, inverse_attribute, name)
    __repr__ = _swig_repr
    bag_type = _ifcopenshell_wrapper.inverse_attribute_bag_type
    set_type = _ifcopenshell_wrapper.inverse_attribute_set_type
    unspecified_type = _ifcopenshell_wrapper.inverse_attribute_unspecified_type

    def __init__(self, name, type_of_aggregation, bound1, bound2, entity_reference, attribute_reference):
        """__init__(IfcParse::inverse_attribute self, std::string const & name, IfcParse::inverse_attribute::aggregate_type type_of_aggregation, int bound1, int bound2, entity entity_reference, attribute attribute_reference) -> inverse_attribute"""
        this = _ifcopenshell_wrapper.new_inverse_attribute(name, type_of_aggregation, bound1, bound2, entity_reference, attribute_reference)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        """name(inverse_attribute self) -> std::string const &"""
        return _ifcopenshell_wrapper.inverse_attribute_name(self)


    def type_of_aggregation(self):
        """type_of_aggregation(inverse_attribute self) -> IfcParse::inverse_attribute::aggregate_type"""
        return _ifcopenshell_wrapper.inverse_attribute_type_of_aggregation(self)


    def bound1(self):
        """bound1(inverse_attribute self) -> int"""
        return _ifcopenshell_wrapper.inverse_attribute_bound1(self)


    def bound2(self):
        """bound2(inverse_attribute self) -> int"""
        return _ifcopenshell_wrapper.inverse_attribute_bound2(self)


    def entity_reference(self):
        """entity_reference(inverse_attribute self) -> entity"""
        return _ifcopenshell_wrapper.inverse_attribute_entity_reference(self)


    def attribute_reference(self):
        """attribute_reference(inverse_attribute self) -> attribute"""
        return _ifcopenshell_wrapper.inverse_attribute_attribute_reference(self)


    def type_of_aggregation_string(self):
        """type_of_aggregation_string(inverse_attribute self) -> std::string"""
        return _ifcopenshell_wrapper.inverse_attribute_type_of_aggregation_string(self)


    def __repr__(self):
    	format_bound = lambda i: "?" if i == -1 else str(i)
    	return "<inverse %s: %s [%s:%s] of %r for %r>" % (
    		self.name(),
    		self.type_of_aggregation_string(),
    		format_bound(self.bound1()),
    		format_bound(self.bound2()),
    		self.entity_reference(),
    		self.attribute_reference()
    	)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_inverse_attribute
    __del__ = lambda self: None
inverse_attribute_swigregister = _ifcopenshell_wrapper.inverse_attribute_swigregister
inverse_attribute_swigregister(inverse_attribute)

class entity(declaration):
    """Proxy of C++ IfcParse::entity class."""

    __swig_setmethods__ = {}
    for _s in [declaration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, entity, name, value)
    __swig_getmethods__ = {}
    for _s in [declaration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, entity, name)
    __repr__ = _swig_repr

    def __init__(self, name, is_abstract, index_in_schema, supertype):
        """__init__(IfcParse::entity self, std::string const & name, bool is_abstract, int index_in_schema, entity supertype) -> entity"""
        this = _ifcopenshell_wrapper.new_entity(name, is_abstract, index_in_schema, supertype)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _is(self, *args):
        """
        _is(entity self, std::string const & name) -> bool
        _is(entity self, declaration decl) -> bool
        """
        return _ifcopenshell_wrapper.entity__is(self, *args)


    def is_abstract(self):
        """is_abstract(entity self) -> bool"""
        return _ifcopenshell_wrapper.entity_is_abstract(self)


    def set_subtypes(self, subtypes):
        """set_subtypes(entity self, std::vector< IfcParse::entity const * > const & subtypes)"""
        return _ifcopenshell_wrapper.entity_set_subtypes(self, subtypes)


    def set_attributes(self, attributes, derived):
        """set_attributes(entity self, std::vector< IfcParse::attribute const * > const & attributes, std::vector< bool > const & derived)"""
        return _ifcopenshell_wrapper.entity_set_attributes(self, attributes, derived)


    def set_inverse_attributes(self, inverse_attributes):
        """set_inverse_attributes(entity self, std::vector< IfcParse::inverse_attribute const * > const & inverse_attributes)"""
        return _ifcopenshell_wrapper.entity_set_inverse_attributes(self, inverse_attributes)


    def subtypes(self):
        """subtypes(entity self) -> std::vector< IfcParse::entity const * > const &"""
        return _ifcopenshell_wrapper.entity_subtypes(self)


    def attributes(self):
        """attributes(entity self) -> std::vector< IfcParse::attribute const * > const &"""
        return _ifcopenshell_wrapper.entity_attributes(self)


    def derived(self):
        """derived(entity self) -> std::vector< bool > const &"""
        return _ifcopenshell_wrapper.entity_derived(self)


    def all_attributes(self):
        """all_attributes(entity self) -> std::vector< IfcParse::attribute const * > const"""
        return _ifcopenshell_wrapper.entity_all_attributes(self)


    def all_inverse_attributes(self):
        """all_inverse_attributes(entity self) -> std::vector< IfcParse::inverse_attribute const * > const"""
        return _ifcopenshell_wrapper.entity_all_inverse_attributes(self)


    def attribute_by_index(self, index):
        """attribute_by_index(entity self, size_t index) -> attribute"""
        return _ifcopenshell_wrapper.entity_attribute_by_index(self, index)


    def attribute_count(self):
        """attribute_count(entity self) -> size_t"""
        return _ifcopenshell_wrapper.entity_attribute_count(self)


    def attribute_index(self, *args):
        """
        attribute_index(entity self, attribute attr) -> ptrdiff_t
        attribute_index(entity self, std::string const & attr_name) -> ptrdiff_t
        """
        return _ifcopenshell_wrapper.entity_attribute_index(self, *args)


    def supertype(self):
        """supertype(entity self) -> entity"""
        return _ifcopenshell_wrapper.entity_supertype(self)


    def as_entity(self):
        """as_entity(entity self) -> entity"""
        return _ifcopenshell_wrapper.entity_as_entity(self)


    def __repr__(self):
    	return "<entity %s>" % (self.name())

    __swig_destroy__ = _ifcopenshell_wrapper.delete_entity
    __del__ = lambda self: None
entity_swigregister = _ifcopenshell_wrapper.entity_swigregister
entity_swigregister(entity)

class instance_factory(_object):
    """Proxy of C++ IfcParse::instance_factory class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, instance_factory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, instance_factory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, data):
        """__call__(instance_factory self, IfcEntityInstanceData data) -> entity_instance"""
        return _ifcopenshell_wrapper.instance_factory___call__(self, data)

    __swig_destroy__ = _ifcopenshell_wrapper.delete_instance_factory
    __del__ = lambda self: None
instance_factory_swigregister = _ifcopenshell_wrapper.instance_factory_swigregister
instance_factory_swigregister(instance_factory)

class schema_definition(_object):
    """Proxy of C++ IfcParse::schema_definition class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, schema_definition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, schema_definition, name)
    __repr__ = _swig_repr

    def __init__(self, name, declarations, factory):
        """__init__(IfcParse::schema_definition self, std::string const & name, std::vector< IfcParse::declaration const * > const & declarations, instance_factory factory) -> schema_definition"""
        this = _ifcopenshell_wrapper.new_schema_definition(name, declarations, factory)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ifcopenshell_wrapper.delete_schema_definition
    __del__ = lambda self: None

    def declaration_by_name(self, *args):
        """
        declaration_by_name(schema_definition self, std::string const & name) -> declaration
        declaration_by_name(schema_definition self, int name) -> declaration
        """
        return _ifcopenshell_wrapper.schema_definition_declaration_by_name(self, *args)


    def declarations(self):
        """declarations(schema_definition self) -> std::vector< IfcParse::declaration const * > const &"""
        return _ifcopenshell_wrapper.schema_definition_declarations(self)


    def type_declarations(self):
        """type_declarations(schema_definition self) -> std::vector< IfcParse::type_declaration const * > const &"""
        return _ifcopenshell_wrapper.schema_definition_type_declarations(self)


    def select_types(self):
        """select_types(schema_definition self) -> std::vector< IfcParse::select_type const * > const &"""
        return _ifcopenshell_wrapper.schema_definition_select_types(self)


    def enumeration_types(self):
        """enumeration_types(schema_definition self) -> std::vector< IfcParse::enumeration_type const * > const &"""
        return _ifcopenshell_wrapper.schema_definition_enumeration_types(self)


    def entities(self):
        """entities(schema_definition self) -> std::vector< IfcParse::entity const * > const &"""
        return _ifcopenshell_wrapper.schema_definition_entities(self)


    def name(self):
        """name(schema_definition self) -> std::string const &"""
        return _ifcopenshell_wrapper.schema_definition_name(self)


    def instantiate(self, data):
        """instantiate(schema_definition self, IfcEntityInstanceData data) -> entity_instance"""
        return _ifcopenshell_wrapper.schema_definition_instantiate(self, data)


    def __repr__(self):
    	return "<schema %s>" % (self.name())

schema_definition_swigregister = _ifcopenshell_wrapper.schema_definition_swigregister
schema_definition_swigregister(schema_definition)


def schema_by_name(arg1):
    """schema_by_name(std::string const & arg1) -> schema_definition"""
    return _ifcopenshell_wrapper.schema_by_name(arg1)

def register_schema(arg1):
    """register_schema(schema_definition arg1)"""
    return _ifcopenshell_wrapper.register_schema(arg1)

def open(fn):
    """open(std::string const & fn) -> file"""
    return _ifcopenshell_wrapper.open(fn)

def read(data):
    """read(std::string const & data) -> file"""
    return _ifcopenshell_wrapper.read(data)

def version():
    """version() -> char const *"""
    return _ifcopenshell_wrapper.version()

def new_IfcBaseClass(schema_identifier, name):
    """new_IfcBaseClass(std::string const & schema_identifier, std::string const & name) -> entity_instance"""
    return _ifcopenshell_wrapper.new_IfcBaseClass(schema_identifier, name)

def get_log():
    """get_log() -> std::string"""
    return _ifcopenshell_wrapper.get_log()

def get_info_cpp(v):
    """get_info_cpp(entity_instance v) -> PyObject *"""
    return _ifcopenshell_wrapper.get_info_cpp(v)
# This file is compatible with both classic and new-style classes.


